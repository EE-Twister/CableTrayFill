<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cable Tray Packing</title>

  <!-- SheetJS / xlsx for Excel import/export. -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 16px;
    }
    h1 {
      margin-bottom: 8px;
      font-size: 1.4rem;
    }
    label {
      display: inline-block;
      width: 120px;
      margin-bottom: 4px;
      font-size: 0.9rem;
    }
    input[type="text"],
    input[type="number"],
    select {
      padding: 2px 4px;
      font-size: 0.9rem;
      margin-right: 8px;
    }
    button {
      padding: 6px 12px;
      font-size: 0.9rem;
      margin: 8px 4px 16px 0;
      cursor: pointer;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 12px;
    }
    table, th, td {
      border: 1px solid #999;
    }
    th, td {
      padding: 6px;
      text-align: center;
      font-size: 0.9rem;
    }
    th {
      background: #f0f0f0;
    }
    #controls {
      margin-bottom: 12px;
    }
    #results {
      margin-top: 16px;
      font-size: 0.95rem;
    }
    #svgContainer {
      border: 1px solid #ccc;
      margin-top: 12px;
    }
    .removeBtn {
      background-color: #e74c3c;
      color: white;
      border: none;
      padding: 4px 8px;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .removeBtn:hover {
      background-color: #c0392b;
    }
    #profileControls {
      margin-top: 16px;
      border: 1px solid #bbb;
      padding: 12px;
      background: #fafafa;
    }
    #profileControls h2 {
      margin-top: 0;
      font-size: 1.1rem;
    }
    #profileList {
      min-width: 160px;
    }
    .warning {
      color: orange;
      font-weight: bold;
    }
    .recommend {
      color: blue;
      font-weight: bold;
    }

    /* OVERLAY + POPUP STYLES */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #popup {
      position: relative;
      background: white;
      padding: 12px;
      border-radius: 8px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #popupClose {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #e74c3c;
      color: white;
      border: none;
      font-size: 1rem;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 4px;
    }
    #copyBtn, #printBtn, #copyPngBtn {
      position: absolute;
      top: 8px;
      font-size: 0.9rem;
      padding: 4px 8px;
      border-radius: 4px;
    }
    #copyBtn {
      right: 80px;
      background: #2ecc71;
      color: white;
      border: none;
      cursor: pointer;
    }
    #copyBtn:hover {
      background: #27ae60;
    }
    #printBtn {
      right: 160px;
      background: #3498db;
      color: white;
      border: none;
      cursor: pointer;
    }
    #printBtn:hover {
      background: #2980b9;
    }
    #copyPngBtn {
      right: 240px;
      background: #9b59b6;
      color: white;
      border: none;
      cursor: pointer;
    }
    #copyPngBtn:hover {
      background: #8e44ad;
    }
    #expandedSVG {
      display: block;
      margin-top: 48px;  /* room for buttons */
    }
  </style>
</head>
<body>
  <h1>
    Cable Tray Packing
  </h1>

  <!-- TRAY PARAMETERS -->
  <fieldset>
    <legend><strong>Tray Parameters</strong></legend>
    <label for="trayWidth">Inside Width (in):</label>
    <input type="number" id="trayWidth" min="6" step="1" value="12" />
    <label for="trayDepth">Load Depth (in):</label>
    <input type="number" id="trayDepth" min="2" step="1" value="3" />
    <label for="trayType">Tray Type:</label>
    <select id="trayType">
      <option value="ladder">Ladder (50 % fill)</option>
      <option value="solid">Solid Bottom (40 % fill)</option>
    </select>
  </fieldset>

  <!-- PROFILE CONTROLS -->
  <div id="profileControls">
    <h2>Profile Management</h2>
    <button id="saveProfileBtn">Save Profile</button>
    <label for="profileList">Load Profile:</label>
    <select id="profileList">
      <option value="">-- no profiles saved --</option>
    </select>
    <button id="loadProfileBtn">Load Profile</button>
    <button id="deleteProfileBtn">Delete Profile</button>
  </div>

  <!-- CABLE ENTRY TABLE -->
  <fieldset>
    <legend><strong>Enter Cables (Type, OD, Weight)</strong></legend>
    <button id="addCableBtn">Add Cable</button>
    <table id="cableTable">
      <thead>
        <tr>
          <th>Tag</th>
          <th>Type</th>
          <th>OD (in)</th>
          <th>Weight (lbs/ft)</th>
          <th>Remove</th>
        </tr>
      </thead>
      <tbody>
        <!-- rows inserted here -->
      </tbody>
    </table>
    <p style="font-size:0.85rem; color:#555; margin-top:8px;">
      You can type any custom Type, OD, and Weight, <strong>or</strong> pick one of the defaults below:
    </p>
    <!-- DATASOURCE for default types -->
    <datalist id="typeList">
      <!-- Will be populated by script -->
    </datalist>
  </fieldset>

  <!-- CONTROLS: Draw, Expand, Import Excel, Export Excel -->
  <div id="controls">
    <button id="drawBtn">Draw Tray</button>
    <button id="expandBtn">Expand Image</button>
    <button id="importExcelBtn">Import Excel</button>
    <button id="exportExcelBtn">Export Excel</button>
    <!-- Hidden file‐picker for .xlsx input -->
    <input type="file" id="importExcelInput" accept=".xlsx" style="display:none" />
  </div>

  <div id="results"></div>
  <div id="svgContainer"></div>

  <!-- OVERLAY + POPUP FOR EXPANDED VIEW -->
  <div id="overlay">
    <div id="popup">
      <button id="popupClose">Close</button>
      <button id="copyPngBtn">Copy PNG</button>
      <button id="printBtn">Print SVG</button>
      <button id="copyBtn">Copy SVG</button>
      <!-- Expanded SVG will be injected here -->
      <div id="expandedSVG"></div>
    </div>
  </div>

  <script>
    (function() {
      // ─────────────────────────────────────────────────────────────
      // (A) Cooper B-Line Default Sizes (3 conductors + ground) :contentReference[oaicite:0]{index=0}
      // ─────────────────────────────────────────────────────────────
      const cableOptions = [
        { label: "3/C – #8 AWG",     OD: 0.66,   weight: 0.33 },
        { label: "3/C – #6 AWG",     OD: 0.74,   weight: 0.45 },
        { label: "3/C – #4 AWG",     OD: 0.88,   weight: 0.66 },
        { label: "3/C – #2 AWG",     OD: 1.00,   weight: 0.96 },
        { label: "3/C – #1 AWG",     OD: 1.13,   weight: 1.17 },
        { label: "3/C – 1/0 AWG",    OD: 1.22,   weight: 1.43 },
        { label: "3/C – 2/0 AWG",    OD: 1.31,   weight: 1.72 },
        { label: "3/C – 3/0 AWG",    OD: 1.42,   weight: 2.14 },
        { label: "3/C – 4/0 AWG",    OD: 1.55,   weight: 2.64 },
        { label: "3/C – 250 kcmil",  OD: 1.76,   weight: 3.18 },
        { label: "3/C – 350 kcmil",  OD: 1.98,   weight: 4.29 },
        { label: "3/C – 500 kcmil",  OD: 2.26,   weight: 5.94 },
        { label: "3/C – 750 kcmil",  OD: 2.71,   weight: 9.01 },
        { label: "3/C – 1000 kcmil", OD: 3.10,   weight: 11.70 }
      ];

      // Populate the <datalist> with default labels
      const typeDatalist = document.getElementById("typeList");
      cableOptions.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.label;
        typeDatalist.appendChild(option);
      });

      // We’ll store last‐drawn data here for “Expand”
      let lastPlaced = null;   // array of {x,y,r,OD,tag,type,weight}
      let lastTrayW   = 0;     // in inches
      let lastTrayD   = 0;     // in inches
      let lastType    = "";    // “ladder” or “solid”
      let lastScale   = 20;    // px/in for small view

      // Reference to the <tbody> of the cable table
      const cableTbody = document.querySelector("#cableTable tbody");

      // ─────────────────────────────────────────────────────────────
      // (B) Helper: create one cable‐entry <tr> (Tag / Type / OD / Weight / Remove)
      // ─────────────────────────────────────────────────────────────
      function createCableRow() {
        const tr = document.createElement("tr");

        // (1) Tag cell
        const tdTag = document.createElement("td");
        const inpTag = document.createElement("input");
        inpTag.type = "text";
        inpTag.placeholder = "e.g. P-20MP007-01";
        inpTag.required = true;
        inpTag.style.width = "120px";
        tdTag.appendChild(inpTag);
        tr.appendChild(tdTag);

        // (2) Type cell (input + datalist for defaults)
        const tdType = document.createElement("td");
        const inpType = document.createElement("input");
        inpType.type = "text";
        inpType.setAttribute("list", "typeList");
        inpType.placeholder = "-- custom or pick default --";
        inpType.style.width = "160px";
        tdType.appendChild(inpType);
        tr.appendChild(tdType);

        // (3) OD cell (number; auto‐filled or custom)
        const tdOD = document.createElement("td");
        const inpOD = document.createElement("input");
        inpOD.type = "number";
        inpOD.placeholder = "0.00";
        inpOD.step = "0.01";
        inpOD.style.width = "60px";
        // Initially read‐only until user picks custom
        inpOD.readOnly = true;
        tdOD.appendChild(inpOD);
        tr.appendChild(tdOD);

        // (4) Weight cell (number; auto‐filled or custom)
        const tdWt = document.createElement("td");
        const inpWt = document.createElement("input");
        inpWt.type = "number";
        inpWt.placeholder = "0.00";
        inpWt.step = "0.01";
        inpWt.style.width = "60px";
        inpWt.readOnly = true;
        tdWt.appendChild(inpWt);
        tr.appendChild(tdWt);

        // (5) Remove button cell
        const tdRm = document.createElement("td");
        const btnRm = document.createElement("button");
        btnRm.textContent = "✖";
        btnRm.className = "removeBtn";
        btnRm.addEventListener("click", () => {
          cableTbody.removeChild(tr);
        });
        tdRm.appendChild(btnRm);
        tr.appendChild(tdRm);

        // When Type changes (either by picking a default or custom‐typing), adjust OD/Weight:
        inpType.addEventListener("input", () => {
          const val = inpType.value.trim();
          const matchIdx = cableOptions.findIndex(o => o.label === val);
          if (matchIdx >= 0) {
            // It matches a default → auto‐fill and lock
            inpOD.value   = cableOptions[matchIdx].OD.toFixed(2);
            inpWt.value   = cableOptions[matchIdx].weight.toFixed(2);
            inpOD.readOnly = true;
            inpWt.readOnly = true;
          } else {
            // Custom type → clear and allow editing
            inpOD.value = "";
            inpWt.value = "";
            inpOD.readOnly = false;
            inpWt.readOnly = false;
          }
        });

        return tr;
      }

      // “Add Cable” button → append a blank row
      document.getElementById("addCableBtn").addEventListener("click", () => {
        cableTbody.appendChild(createCableRow());
      });
      // Start with one empty row
      document.getElementById("addCableBtn").click();

      // ─────────────────────────────────────────────────────────────
      // (C) NEC-2011 Sizing Helpers (Table 5 allowable area for small) :contentReference[oaicite:1]{index=1}
      // ─────────────────────────────────────────────────────────────
      const allowableAreaByWidth = {
        6:  7.0,
        9: 10.5,
        12:14.0,
        18:21.0,
        24:28.0,
        30:32.5,
        36:39.0
      };
      const standardWidths = [6, 9, 12, 18, 24, 30, 36];

      function splitLargeSmall(cables) {
        const large = [], small = [];
        cables.forEach(c => {
          if (c.OD >= 1.55) large.push(c);
          else small.push(c);
        });
        return { large, small };
      }
      function sumDiameters(arr) {
        return arr.reduce((sum, c) => sum + c.OD, 0);
      }
      function sumAreas(arr) {
        return arr.reduce((sum, c) => sum + Math.PI * (c.OD/2)**2, 0);
      }
      function getAllowableArea(width, trayType) {
        const base = allowableAreaByWidth[width] || 0;
        return (trayType === "solid") ? base * 0.78 : base;
      }
      function computeNeededWidth(large, small, trayType) {
        let widthNeededLarge = 0;
        if (large.length > 0) {
          const sumD = sumDiameters(large);
          widthNeededLarge = (trayType === "solid") ? (sumD / 0.9) : sumD;
        }
        const areaNeededSmall = sumAreas(small);

        for (const W of standardWidths) {
          if (W < widthNeededLarge) continue;
          const allowA = getAllowableArea(W, trayType);
          if (small.length === 0 || areaNeededSmall <= allowA) {
            return W;
          }
        }
        return null;
      }

      // ─────────────────────────────────────────────────────────────
      // (D) Placement Helpers (IGNORE bounds, force‐draw)
      //   (1) placeLargeIgnoreBounds – single bottom row for large
      //   (2) placeSmallByPacking – “true packing” for small
      // ─────────────────────────────────────────────────────────────

      // (1) Place large cables bottom row (y = r), ignoring tray width
      function placeLargeIgnoreBounds(largeCables) {
        const placed = [];
        let runningX = 0;
        largeCables.forEach((c, i) => {
          const r = c.OD / 2;
          if (i === 0) {
            runningX = r;
          } else {
            const prev = placed[i - 1];
            runningX = prev.x + prev.r + r;
          }
          placed.push({
            x: runningX,
            y: r,
            r: r,
            OD: c.OD,
            tag: c.tag,
            type: c.type,
            weight: c.weight
          });
        });
        return placed;
      }

      // (2) Place small cables via “tangent‐circle” packing
      function placeSmallByPacking(smallCables, trayW, barrierX, basePlaced) {
        const placed = basePlaced.map(p => ({
          x: p.x,
          y: p.y,
          r: p.r,
          OD: p.OD,
          tag: p.tag,
          type: p.type,
          weight: p.weight
        }));
        const sorted = smallCables.slice().sort((a, b) => b.OD - a.OD);
        const EPS = 1e-6;

        sorted.forEach(c => {
          const r = c.OD / 2;
          let best = { x: null, y: Infinity };
          const candidates = [];

          // A1) Floor‐only at x = barrierX + r, y = r
          candidates.push({ x: barrierX + r, y: r });

          // A2) Tangent to floor + one placed circle p → x = p.x ± (p.r + r), y = r
          placed.forEach(p => {
            const leftX  = p.x - (p.r + r);
            const rightX = p.x + (p.r + r);
            if (leftX >= barrierX + r - EPS && leftX <= trayW - r + EPS) {
              candidates.push({ x: leftX, y: r });
            }
            if (rightX >= barrierX + r - EPS && rightX <= trayW - r + EPS) {
              candidates.push({ x: rightX, y: r });
            }
          });

          // A3) Tangent to two placed circles p & q (circle‐circle intersection)
          for (let i = 0; i < placed.length; i++) {
            const p = placed[i];
            const R1 = p.r + r;
            for (let j = i + 1; j < placed.length; j++) {
              const q = placed[j];
              const R2 = q.r + r;
              const dx = q.x - p.x, dy = q.y - p.y;
              const d2 = dx*dx + dy*dy, d = Math.sqrt(d2);
              // Skip if no intersection
              if (d < EPS || d > R1 + R2 - EPS || d < Math.abs(R1 - R2) + EPS) {
                continue;
              }
              const a = (R1*R1 - R2*R2 + d2) / (2 * d);
              const h2 = R1*R1 - a*a;
              if (h2 < -EPS) continue;
              const h = Math.sqrt(Math.max(0, h2));
              const xm = p.x + (a * dx / d);
              const ym = p.y + (a * dy / d);
              const rx = -dy * (h / d), ry = dx * (h / d);

              const cand1 = { x: xm + rx, y: ym + ry };
              const cand2 = { x: xm - rx, y: ym - ry };
              [cand1, cand2].forEach(({x, y}) => {
                if (
                  x >= barrierX + r - EPS &&
                  x <= trayW - r + EPS &&
                  y >= r - EPS
                ) {
                  candidates.push({ x: x, y: y });
                }
              });
            }
          }

          // A4) Tangent to barrier + one placed circle p
          placed.forEach(p => {
            const cx = barrierX + r;
            const dx = Math.abs(cx - p.x);
            const R = p.r + r;
            if (dx < R - EPS) {
              const offset = Math.sqrt(Math.max(0, R*R - dx*dx));
              const yCand1 = p.y + offset;
              if (yCand1 >= r - EPS) {
                candidates.push({ x: cx, y: yCand1 });
              }
            }
          });

          // B) FILTER candidates (must not overlap and be in bounds)
          candidates.forEach(pos => {
            const xCand = pos.x;
            const yCand = pos.y;
            if (xCand - r < barrierX - EPS || xCand + r > trayW + EPS) return;
            if (yCand - r < -EPS) return;
            let overl = false;
            for (const p of placed) {
              const dx = xCand - p.x;
              const dy = yCand - p.y;
              const req = p.r + r;
              if (dx*dx + dy*dy < (req - EPS)*(req - EPS)) {
                overl = true;
                break;
              }
            }
            if (!overl) {
              if (
                yCand < best.y - EPS ||
                (Math.abs(yCand - best.y) < EPS && xCand < best.x)
              ) {
                best = { x: xCand, y: yCand };
              }
            }
          });

          // C) FALL BACK if no valid tangent position found
          if (best.x === null) {
            const xForced = barrierX + r;
            let yForced = r;
            placed.forEach(p => {
              const dx = Math.abs(xForced - p.x);
              if (dx < p.r + r - EPS) {
                const supTop = p.y + p.r + r;
                if (supTop > yForced) yForced = supTop;
              }
            });
            best = { x: xForced, y: yForced };
          }

          // D) Commit placement
          placed.push({
            x: best.x,
            y: best.y,
            r: r,
            OD: c.OD,
            tag: c.tag,
            type: c.type,
            weight: c.weight
          });
        });

        return placed;
      }


      // ─────────────────────────────────────────────────────────────
      // (E) “Draw Tray” button: collect inputs → compute metrics → place → draw small SVG → show warnings
      // ─────────────────────────────────────────────────────────────
      document.getElementById("drawBtn").addEventListener("click", () => {
        // 1) Tray parameters
        const trayW = parseFloat(document.getElementById("trayWidth").value);
        const trayD = parseFloat(document.getElementById("trayDepth").value);
        const trayType = document.getElementById("trayType").value;

        // 2) Gather cables from the table
        const rows = Array.from(cableTbody.querySelectorAll("tr"));
        const cables = [];
        for (const row of rows) {
          const tagVal  = row.children[0].querySelector("input").value.trim();
          const typeVal = row.children[1].querySelector("input").value.trim();
          const odVal   = parseFloat(row.children[2].querySelector("input").value);
          const wtVal   = parseFloat(row.children[3].querySelector("input").value);

          if (!tagVal) {
            alert("ERROR: Every cable row requires a Tag.");
            return;
          }
          if (!typeVal) {
            alert(`ERROR: Every cable row requires a Type (default or custom).`);
            return;
          }
          if (isNaN(odVal) || isNaN(wtVal)) {
            alert(`ERROR: Every cable row requires numeric OD and Weight.`);
            return;
          }

          cables.push({
            tag: tagVal,
            type: typeVal,
            OD: odVal,
            weight: wtVal
          });
        }
        if (cables.length === 0) {
          alert("ERROR: Add at least one cable before drawing the tray.");
          return;
        }

        // 3) Compute extra metrics:
        let sumSmallArea = 0;
        let sumLargeDiam = 0;
        cables.forEach(c => {
          if (c.OD < 1.55) {
            sumSmallArea += Math.PI * (c.OD/2)**2;
          } else {
            sumLargeDiam += c.OD;
          }
        });

        // 4) Split large vs. small, compute recommended width
        const { large, small } = splitLargeSmall(cables);
        const recommendedWidth = computeNeededWidth(large, small, trayType);

        // 5) Summarize metrics + total weight
        const totalWeight = cables.reduce((sum, c) => sum + c.weight, 0);
        let resultsHTML = `
          <p>
            <strong>Using Tray Width:</strong> ${trayW}"<br/>
            <strong>Tray Depth:</strong> ${trayD}"<br/>
            <strong>Type:</strong> ${trayType === "ladder" ? "Ladder (50 % fill)" : "Solid Bottom (40 % fill)"}
          </p>
          <p>
            <strong>Cables Smaller than 4/0 Cross-Sectional Area:</strong>
            ${sumSmallArea.toFixed(2)} in²
          </p>
          <p>
            <strong>Sum of 4/0 and Larger Cable Diameters:</strong>
            ${sumLargeDiam.toFixed(2)} in
          </p>
          <p>
            <strong>Total Cable Weight:</strong> ${totalWeight.toFixed(2)} lbs/ft
          </p>
        `;

        // 6) Place all cables ignoring horizontal/vertical bounds
        let placedAll = [];
        let barrierX = 0;

        if (large.length > 0 && small.length > 0) {
          const largePlaced = placeLargeIgnoreBounds(large);
          barrierX = Math.max(...largePlaced.map(p => p.x + p.r));
          const smallPlaced = placeSmallByPacking(small, trayW, barrierX, largePlaced);
          placedAll = largePlaced.concat(smallPlaced.slice(largePlaced.length));
        }
        else if (large.length > 0) {
          placedAll = placeLargeIgnoreBounds(large);
        }
        else {
          placedAll = placeSmallByPacking(small, trayW, 0, []);
        }

        // Store for “Expand Image”
        lastPlaced = placedAll;
        lastTrayW   = trayW;
        lastTrayD   = trayD;
        lastType    = trayType;
        lastScale   = 20;  // px/in for small view

        // 7) Detect overflow horizontally/vertically
        let overflowHoriz = false;
        let overflowVert  = false;
        placedAll.forEach(p => {
          if (p.x + p.r > trayW + 1e-6) overflowHoriz = true;
          if (p.y + p.r > trayD + 1e-6) overflowVert  = true;
        });

        // 8) Draw the small SVG (20 px/in)
        const svgW = trayW * lastScale;
        const svgH = trayD * lastScale;
        let svg = `<svg width="${svgW}" height="${svgH}" style="background:#f9f9f9; border:1px solid #999;">`;
        svg += `<rect x="0" y="0" width="${svgW}" height="${svgH}" fill="none" stroke="#333" stroke-width="2"/>`;
        if (large.length > 0 && small.length > 0) {
          const barXpx = barrierX * lastScale;
          svg += `<line x1="${barXpx.toFixed(2)}" y1="0" x2="${barXpx.toFixed(2)}" y2="${svgH}"
                           stroke="#aa3300" stroke-width="2" stroke-dasharray="4 2"/>`;
        }
        placedAll.forEach(p => {
          const cx = p.x * lastScale;
          const cy = (trayD - p.y) * lastScale; // flip Y
          const r  = p.r * lastScale;
          svg += `
            <circle
              cx="${cx.toFixed(2)}"
              cy="${cy.toFixed(2)}"
              r="${r.toFixed(2)}"
              fill="#66ccff"
              stroke="#0066aa"
              stroke-width="1"
            >
              <title>
Tag: ${p.tag}
Type: ${p.type}
OD: ${p.OD.toFixed(2)}″
Wt: ${p.weight.toFixed(2)} lbs/ft
              </title>
            </circle>`;
        });
        svg += `</svg>`;
        document.getElementById("svgContainer").innerHTML = svg;

        // 9) Show overflow warnings & recommendations
        if (overflowHoriz || overflowVert) {
          if (overflowHoriz) {
            if (recommendedWidth && recommendedWidth > trayW) {
              resultsHTML += `
                <p class="warning">
                  WARNING: Some cables extend beyond the tray width (${trayW}").
                </p>
                <p class="recommend">
                  Recommend trying a larger standard width: ${recommendedWidth}" 
                </p>`;
            } else {
              resultsHTML += `
                <p class="warning">
                  WARNING: Some cables extend beyond the tray width (${trayW}").
                </p>
                <p class="recommend">
                  No larger standard width can accommodate all cables.
                </p>`;
            }
          }
          if (overflowVert) {
            const neededDepth = Math.max(...placedAll.map(p => p.y + p.r));
            resultsHTML += `
              <p class="warning">
                WARNING: Some cables extend above the tray depth (${trayD}").
              </p>
              <p class="recommend">
                Recommend increasing tray depth to at least ${neededDepth.toFixed(2)}".
              </p>`;
          }
        }
        document.getElementById("results").innerHTML = resultsHTML;
      });

      // ─────────────────────────────────────────────────────────────
      // (F) “Expand Image” button: show a popup at 160 px/in (twice larger again)
      // ─────────────────────────────────────────────────────────────
      document.getElementById("expandBtn").addEventListener("click", () => {
        if (!lastPlaced) {
          alert("Please click “Draw Tray” first, then Expand.");
          return;
        }
        // Build new SVG at 160 px/in
        const bigScale = 160;
        const trayW = lastTrayW, trayD = lastTrayD;
        const svgW = trayW * bigScale;
        const svgH = trayD * bigScale;
        let svg = `<svg width="${svgW}" height="${svgH}" style="background:#f9f9f9; border:1px solid #333;">`;

        svg += `<rect x="0" y="0" width="${svgW}" height="${svgH}" fill="none" stroke="#333" stroke-width="4"/>`;

        const largeCables = lastPlaced.filter(p => p.OD >= 1.55);
        const smallCables = lastPlaced.filter(p => p.OD < 1.55);
        if (largeCables.length > 0 && smallCables.length > 0) {
          const barrierX = Math.max(...largeCables.map(p => p.x + p.r));
          const barXpx = barrierX * bigScale;
          svg += `<line x1="${barXpx.toFixed(2)}" y1="0" x2="${barXpx.toFixed(2)}" y2="${svgH}"
                           stroke="#aa3300" stroke-width="4" stroke-dasharray="12 6"/>`;
        }

        lastPlaced.forEach(p => {
          const cx = p.x * bigScale;
          const cy = (trayD - p.y) * bigScale;
          const r  = p.r * bigScale;
          svg += `
            <circle
              cx="${cx.toFixed(2)}"
              cy="${cy.toFixed(2)}"
              r="${r.toFixed(2)}"
              fill="#66ccff"
              stroke="#0066aa"
              stroke-width="2"
            />`;

          // Insert multiline <text> inside
          const fontSize = Math.min(r * 0.15, 18);
          const lines = [
            `Tag: ${p.tag}`,
            `Type: ${p.type}`,
            `OD: ${p.OD.toFixed(2)}″`,
            `Wt: ${p.weight.toFixed(2)}`
          ];
          const lineHeight = fontSize * 1.1;
          const textBlockHeight = lines.length * lineHeight;
          let yStart = cy - textBlockHeight / 2 + lineHeight / 2;

          lines.forEach((ln, idx) => {
            svg += `
              <text x="${cx.toFixed(2)}" y="${(yStart + idx * lineHeight).toFixed(2)}"
                    font-size="${fontSize}px"
                    text-anchor="middle"
                    fill="#000"
                    stroke="none"
                    font-family="Arial, sans-serif"
                    pointer-events="none"
              >
                ${ln}
              </text>`;
          });
        });

        svg += `</svg>`;

        document.getElementById("expandedSVG").innerHTML = svg;
        document.getElementById("overlay").style.display = "flex";
      });

      // ─────────────────────────────────────────────────────────────
      // (G) Copy SVG to clipboard
      // ─────────────────────────────────────────────────────────────
      document.getElementById("copyBtn").addEventListener("click", () => {
        const container = document.getElementById("expandedSVG");
        const svgElem = container.querySelector("svg");
        if (!svgElem) {
          alert("No expanded SVG found to copy.");
          return;
        }
        const svgText = svgElem.outerHTML;
        navigator.clipboard.writeText(svgText).then(() => {
          alert("SVG markup copied to clipboard!");
        }).catch(err => {
          alert("Error copying SVG: " + err);
        });
      });

      // ─────────────────────────────────────────────────────────────
      // (H) Print SVG in new window
      // ─────────────────────────────────────────────────────────────
      document.getElementById("printBtn").addEventListener("click", () => {
        const container = document.getElementById("expandedSVG");
        const svgElem = container.querySelector("svg");
        if (!svgElem) {
          alert("No expanded SVG found to print.");
          return;
        }
        const svgText = svgElem.outerHTML;
        const printWindow = window.open("", "_blank");
        printWindow.document.write(`<!DOCTYPE html>
<html>
<head>
  <title>Print Cable Tray</title>
</head>
<body style="margin:0; padding:0;">
  ${svgText}
</body>
</html>`);
        printWindow.document.close();
        printWindow.focus();
        setTimeout(() => {
          printWindow.print();
        }, 200);
      });

      // ─────────────────────────────────────────────────────────────
      // (I) Copy PNG to clipboard: SVG → canvas → PNG Blob → clipboard
      // ─────────────────────────────────────────────────────────────
      document.getElementById("copyPngBtn").addEventListener("click", () => {
        const container = document.getElementById("expandedSVG");
        const svgElem = container.querySelector("svg");
        if (!svgElem) {
          alert("No expanded SVG found to copy as PNG.");
          return;
        }
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgElem);
        const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);

        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width  = svgElem.getAttribute("width");
          canvas.height = svgElem.getAttribute("height");
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          canvas.toBlob(pngBlob => {
            if (!pngBlob) {
              alert("Failed to create PNG blob.");
              URL.revokeObjectURL(url);
              return;
            }
            const clipboardItem = new ClipboardItem({ "image/png": pngBlob });
            navigator.clipboard.write([clipboardItem]).then(() => {
              alert("PNG copied to clipboard!");
              URL.revokeObjectURL(url);
            }).catch(err => {
              alert("Error copying PNG: " + err);
              URL.revokeObjectURL(url);
            });
          }, "image/png");
        };
        img.onerror = () => {
          alert("Failed to load SVG into image for PNG conversion.");
          URL.revokeObjectURL(url);
        };
        img.src = url;
      });

      // ─────────────────────────────────────────────────────────────
      // (J) “Close” button hides the overlay
      // ─────────────────────────────────────────────────────────────
      document.getElementById("popupClose").addEventListener("click", () => {
        document.getElementById("overlay").style.display = "none";
      });

      // ─────────────────────────────────────────────────────────────
      // (K) Excel Export: gather table → create workbook → download
      // ─────────────────────────────────────────────────────────────
      document.getElementById("exportExcelBtn").addEventListener("click", () => {
        const rows = Array.from(cableTbody.querySelectorAll("tr"));
        if (rows.length === 0) {
          alert("No cables to export.");
          return;
        }
        // Build 2D array: header + each row
        const data = [["Tag", "Type", "OD", "Weight"]];
        rows.forEach(row => {
          const tag   = row.children[0].querySelector("input").value.trim();
          const type  = row.children[1].querySelector("input").value.trim();
          const od    = row.children[2].querySelector("input").value.trim();
          const weight= row.children[3].querySelector("input").value.trim();
          data.push([tag, type, od, weight]);
        });
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(wb, ws, "Cables");
        XLSX.writeFile(wb, "CableList.xlsx");
      });

      // ─────────────────────────────────────────────────────────────
      // (L) Excel Import: file‐picker → parse → populate table
      // ─────────────────────────────────────────────────────────────
      document.getElementById("importExcelBtn").addEventListener("click", () => {
        document.getElementById("importExcelInput").click();
      });
      document.getElementById("importExcelInput").addEventListener("change", (evt) => {
        const file = evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const data = e.target.result;
          const wb = XLSX.read(data, { type: "binary" });
          const firstSheet = wb.Sheets[wb.SheetNames[0]];
          const jsonArr = XLSX.utils.sheet_to_json(firstSheet, { defval: "" });
          if (jsonArr.length === 0) {
            alert("Excel sheet is empty.");
            return;
          }
          // Expect columns: Tag, Type, OD, Weight
          cableTbody.innerHTML = "";
          jsonArr.forEach((obj, idx) => {
            const { Tag, Type, OD, Weight } = obj;
            if (typeof Tag === "undefined" || typeof Type === "undefined" ||
                typeof OD === "undefined" || typeof Weight === "undefined") {
              alert(`Row ${idx+2} missing one of: Tag, Type, OD, Weight.`);
              return;
            }
            const newRow = createCableRow();
            newRow.children[0].querySelector("input").value = Tag;
            newRow.children[1].querySelector("input").value = Type;
            // Trigger input event to auto-fill or allow custom:
            const typeInput = newRow.children[1].querySelector("input");
            typeInput.dispatchEvent(new Event("input"));
            // If it was a default, OD/Weight auto-filled. If not, fill manually:
            const odInput = newRow.children[2].querySelector("input");
            const wtInput = newRow.children[3].querySelector("input");
            if (cableOptions.findIndex(o => o.label === Type) < 0) {
              odInput.value = parseFloat(OD).toFixed(2);
              wtInput.value = parseFloat(Weight).toFixed(2);
              odInput.readOnly = false;
              wtInput.readOnly = false;
            }
            cableTbody.appendChild(newRow);
          });
          alert("Excel imported. Correct any unrecognized Types if needed.");
          document.getElementById("importExcelInput").value = "";
        };
        reader.readAsBinaryString(file);
      });

      // ─────────────────────────────────────────────────────────────
      // (M) Profile Management (localStorage)
      // ─────────────────────────────────────────────────────────────
      const profileList = document.getElementById("profileList");
      function refreshProfileList() {
        profileList.innerHTML = "";
        const keys = Object.keys(localStorage).filter(k => k.startsWith("trayProfile_"));
        if (keys.length === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "-- no profiles saved --";
          profileList.appendChild(opt);
          return;
        }
        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "-- select profile --";
        profileList.appendChild(defaultOpt);
        keys.sort();
        keys.forEach(key => {
          const profileName = key.replace("trayProfile_", "");
          const opt = document.createElement("option");
          opt.value = profileName;
          opt.textContent = profileName;
          profileList.appendChild(opt);
        });
      }

      // Save profile
      document.getElementById("saveProfileBtn").addEventListener("click", () => {
        const name = prompt("Enter a name for this cable profile:");
        if (!name) return;
        const rows = Array.from(cableTbody.querySelectorAll("tr"));
        const arr = [];
        for (const row of rows) {
          const tagVal  = row.children[0].querySelector("input").value.trim();
          const typeVal = row.children[1].querySelector("input").value.trim();
          const odVal   = parseFloat(row.children[2].querySelector("input").value);
          const wtVal   = parseFloat(row.children[3].querySelector("input").value);
          if (!tagVal || !typeVal || isNaN(odVal) || isNaN(wtVal)) {
            alert("All rows must have Tag, Type, OD, and Weight before saving.");
            return;
          }
          arr.push({
            tag: tagVal,
            type: typeVal,
            OD: odVal,
            weight: wtVal
          });
        }
        try {
          localStorage.setItem("trayProfile_" + name, JSON.stringify(arr));
          alert(`Profile "${name}" saved.`);
          refreshProfileList();
        } catch (e) {
          alert("Error saving profile: " + e.message);
        }
      });

      // Load profile
      document.getElementById("loadProfileBtn").addEventListener("click", () => {
        const profileName = profileList.value;
        if (!profileName) {
          alert("Select a profile to load.");
          return;
        }
        const json = localStorage.getItem("trayProfile_" + profileName);
        if (!json) {
          alert(`Profile "${profileName}" not found.`);
          refreshProfileList();
          return;
        }
        let arr;
        try {
          arr = JSON.parse(json);
        } catch (e) {
          alert("Error parsing profile data: " + e.message);
          return;
        }
        cableTbody.innerHTML = "";
        arr.forEach(cable => {
          const newRow = createCableRow();
          newRow.children[0].querySelector("input").value = cable.tag;
          newRow.children[1].querySelector("input").value = cable.type;
          // Trigger input event to auto-fill or allow custom
          const typeInput = newRow.children[1].querySelector("input");
          typeInput.dispatchEvent(new Event("input"));
          const odInput = newRow.children[2].querySelector("input");
          const wtInput = newRow.children[3].querySelector("input");
          if (cableOptions.findIndex(o => o.label === cable.type) < 0) {
            odInput.value = cable.OD.toFixed(2);
            wtInput.value = cable.weight.toFixed(2);
            odInput.readOnly = false;
            wtInput.readOnly = false;
          }
          cableTbody.appendChild(newRow);
        });
        alert(`Profile "${profileName}" loaded.`);
      });

      // Delete profile
      document.getElementById("deleteProfileBtn").addEventListener("click", () => {
        const profileName = profileList.value;
        if (!profileName) {
          alert("Select a profile to delete.");
          return;
        }
        if (!confirm(`Delete profile "${profileName}"?`)) return;
        localStorage.removeItem("trayProfile_" + profileName);
        alert(`Profile "${profileName}" deleted.`);
        refreshProfileList();
      });

      // Initialize profile dropdown
      refreshProfileList();
    })();
  </script>
</body>
</html>
