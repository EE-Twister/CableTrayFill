<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cable Tray Packing</title>

  <!-- SheetJS / xlsx for Excel import/export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 16px;
    }
    h1 {
      margin-bottom: 8px;
      font-size: 1.4rem;
    }
    label {
      display: inline-block;
      margin-bottom: 4px;
      font-size: 0.9rem;
    }
    input[type="text"],
    input[type="number"],
    select {
      padding: 2px 4px;
      font-size: 0.9rem;
      margin-right: 8px;
    }
    button {
      padding: 6px 12px;
      font-size: 0.9rem;
      margin: 8px 4px 16px 0;
      cursor: pointer;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 12px;
    }
    table, th, td {
      border: 1px solid #999;
    }
    th, td {
      padding: 6px;
      text-align: center;
      font-size: 0.9rem;
    }
    th {
      background: #f0f0f0;
    }
    #controls {
      margin-bottom: 12px;
    }
    #results {
      margin-top: 16px;
      font-size: 0.95rem;
    }
    #svgContainer {
      border: 1px solid #ccc;
      margin-top: 12px;
    }
    .removeBtn {
      background-color: #e74c3c;
      color: white;
      border: none;
      padding: 4px 8px;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .removeBtn:hover {
      background-color: #c0392b;
    }
    .duplicateBtn {
      background-color: #95a5a6;
      color: white;
      border: none;
      padding: 4px 8px;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .duplicateBtn:hover {
      background-color: #7f8c8d;
    }
    #profileControls {
      margin-top: 16px;
      border: 1px solid #bbb;
      padding: 12px;
      background: #fafafa;
    }
    #profileControls h2 {
      margin-top: 0;
      font-size: 1.1rem;
    }
    #profileList {
      min-width: 160px;
    }
    .warning {
      color: orange;
      font-weight: bold;
    }
    .recommend {
      color: blue;
      font-weight: bold;
    }
    .nfpaWarn {
      color: red;
      font-weight: bold;
    }

    /* OVERLAY + POPUP STYLES */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #popup {
      position: relative;
      background: white;
      padding: 12px;
      border-radius: 8px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #popupClose {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #e74c3c;
      color: white;
      border: none;
      font-size: 1rem;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 4px;
    }
    #copyBtn, #printBtn, #copyPngBtn {
      position: absolute;
      top: 8px;
      font-size: 0.9rem;
      padding: 4px 8px;
      border-radius: 4px;
    }
    #copyBtn {
      right: 80px;
      background: #2ecc71;
      color: white;
      border: none;
      cursor: pointer;
    }
    #copyBtn:hover {
      background: #27ae60;
    }
    #printBtn {
      right: 160px;
      background: #3498db;
      color: white;
      border: none;
      cursor: pointer;
    }
    #printBtn:hover {
      background: #2980b9;
    }
    #copyPngBtn {
      right: 240px;
      background: #9b59b6;
      color: white;
      border: none;
      cursor: pointer;
    }
    #copyPngBtn:hover {
      background: #8e44ad;
    }
    #expandedSVG {
      display: block;
      margin-top: 48px;  /* room for buttons */
    }
  </style>
</head>
<body>
  <h1>Cable Tray Packing</h1>

  <!-- TRAY PARAMETERS -->
  <fieldset>
    <legend><strong>Tray Parameters</strong></legend>

    <label for="trayWidth">Inside Width (in):</label>
    <input type="number" id="trayWidth" min="6" step="1" value="12" />

    <label for="trayDepth">Load Depth (in):</label>
    <input type="number" id="trayDepth" min="2" step="1" value="3" />

    <label for="trayType">Tray Type:</label>
    <select id="trayType">
      <option value="ladder">Ladder (50 % fill)</option>
      <option value="solid">Solid Bottom (40 % fill)</option>
    </select>
    <br/>

    <!-- 1) New “Tray Name” input -->
    <label for="trayName">Tray Name:</label>
    <input type="text" id="trayName" placeholder="e.g. Main Power Run" style="width:200px;" />
  </fieldset>

  <!-- PROFILE CONTROLS -->
  <div id="profileControls">
    <h2>Profile Management</h2>
    <button id="saveProfileBtn" type="button">Save Profile</button>
    <label for="profileList">Load Profile:</label>
    <select id="profileList">
      <option value="">-- no profiles saved --</option>
    </select>
    <button id="loadProfileBtn" type="button">Load Profile</button>
    <button id="deleteProfileBtn" type="button">Delete Profile</button>
  </div>

  <!-- CABLE ENTRY TABLE -->
  <fieldset>
    <legend><strong>Enter Cables</strong></legend>
    <button id="addCableBtn" type="button">Add Cable</button>
    <table id="cableTable">
      <thead>
        <tr>
          <th>Tag</th>
          <th>Cable Type</th>
          <th>Cable Configuration</th>
          <th>OD (in)</th>
          <th>Weight (lbs/ft)</th>
          <th>Multiconductor Cable</th>
          <th>Cable Group</th>
          <th>Duplicate</th>
          <th>Remove</th>
        </tr>
      </thead>
      <tbody>
        <!-- rows inserted here by script -->
      </tbody>
    </table>
    <p style="font-size:0.85rem; color:#555; margin-top:8px;">
      <strong>Cable Configuration:</strong> Type any custom configuration or pick one of the defaults.<br>
      OD & Weight auto-fill if you select a default.
    </p>
    <!-- DATASOURCE for default configurations -->
    <datalist id="typeList">
      <!-- Populated by script -->
    </datalist>
  </fieldset>

  <!-- CONTROLS: Spacing Checkbox + Draw, Expand, Import/Export -->
  <div id="controls">
    <label>
      <input type="checkbox" id="largeSpacing" />
      Add one‐diameter spacing between 4/0+ cables
    </label>
    <br/>
    <button id="drawBtn" type="button">Draw Tray</button>
    <button id="expandBtn" type="button">Expand Image</button>
    <button id="importExcelBtn" type="button">Import Excel</button>
    <button id="exportExcelBtn" type="button">Export Excel</button>
    <button id="importHelpBtn" type="button">Import Help</button>
    <!-- Hidden file‐picker for .xlsx input -->
    <input type="file" id="importExcelInput" accept=".xlsx" style="display:none" />
  </div>

  <div id="results"></div>
  <div id="svgContainer"></div>

  <!-- OVERLAY + POPUP FOR EXPANDED VIEW -->
  <div id="overlay">
    <div id="popup">
      <button id="popupClose" type="button">Close</button>
      <button id="copyPngBtn" type="button">Copy PNG</button>
      <button id="printBtn" type="button">Print SVG</button>
      <button id="copyBtn" type="button">Copy SVG</button>
      <!-- Expanded SVG will be injected here -->
      <div id="expandedSVG"></div>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // ─────────────────────────────────────────────────────────────
      // (A) Default Configurations (3 conductors + ground) :contentReference[oaicite:0]{index=0}
      // ─────────────────────────────────────────────────────────────
      const cableOptions = [
        { label: "3/C – #8 AWG",     OD: 0.66,   weight: 0.33 },
        { label: "3/C – #6 AWG",     OD: 0.74,   weight: 0.45 },
        { label: "3/C – #4 AWG",     OD: 0.88,   weight: 0.66 },
        { label: "3/C – #2 AWG",     OD: 1.00,   weight: 0.96 },
        { label: "3/C – #1 AWG",     OD: 1.13,   weight: 1.17 },
        { label: "3/C – 1/0 AWG",    OD: 1.22,   weight: 1.43 },
        { label: "3/C – 2/0 AWG",    OD: 1.31,   weight: 1.72 },
        { label: "3/C – 3/0 AWG",    OD: 1.42,   weight: 2.14 },
        { label: "3/C – 4/0 AWG",    OD: 1.55,   weight: 2.64 },
        { label: "3/C – 250 kcmil",  OD: 1.76,   weight: 3.18 },
        { label: "3/C – 350 kcmil",  OD: 1.98,   weight: 4.29 },
        { label: "3/C – 500 kcmil",  OD: 2.26,   weight: 5.94 },
        { label: "3/C – 750 kcmil",  OD: 2.71,   weight: 9.01 },
        { label: "3/C – 1000 kcmil", OD: 3.10,   weight: 11.70 }
      ];

      // Populate the <datalist> (#typeList) with default labels
      const typeDatalist = document.getElementById("typeList");
      cableOptions.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.label;
        typeDatalist.appendChild(option);
      });

      // We’ll store last‐drawn data here (for “Expand Image”)
      let lastPlaced = null;   // array of { x, y, r, OD, tag, cableType, config, weight }
      let lastBarriers = [];   // x positions of separation barriers
      let lastTrayW   = 0;     // in inches
      let lastTrayD   = 0;     // in inches
      let lastType    = "";    // “ladder” or “solid”
      let lastScale   = 20;    // px/in for small view

      // Reference to <tbody> in the cable table
      const cableTbody = document.querySelector("#cableTable tbody");

      // ─────────────────────────────────────────────────────────────
      // (B) Helper: create one cable‐entry <tr> (Tag / Cable Type / Configuration / OD / Weight / Remove)
      // ─────────────────────────────────────────────────────────────
      function createCableRow() {
        const tr = document.createElement("tr");

        // (1) Tag cell
        const tdTag = document.createElement("td");
        const inpTag = document.createElement("input");
        inpTag.type = "text";
        inpTag.placeholder = "e.g. P-20MP007-01";
        inpTag.required = true;
        inpTag.style.width = "120px";
        tdTag.appendChild(inpTag);
        tr.appendChild(tdTag);

        // (2) Cable Type cell (dropdown: Power, Control, Signal)
        const tdCableType = document.createElement("td");
        const selCableType = document.createElement("select");
        selCableType.style.width = "120px";
        const emptyOpt = document.createElement("option");
        emptyOpt.value = "";
        emptyOpt.textContent = "-- select --";
        selCableType.appendChild(emptyOpt);
        ["Power", "Control", "Signal"].forEach(optText => {
          const o = document.createElement("option");
          o.value = optText;
          o.textContent = optText;
          selCableType.appendChild(o);
        });
        tdCableType.appendChild(selCableType);
        tr.appendChild(tdCableType);

        // (3) Cable Configuration cell (input + datalist)
        const tdConfig = document.createElement("td");
        const inpConfig = document.createElement("input");
        inpConfig.type = "text";
        inpConfig.setAttribute("list", "typeList");
        inpConfig.placeholder = "-- custom or pick default --";
        inpConfig.style.width = "160px";
        tdConfig.appendChild(inpConfig);
        tr.appendChild(tdConfig);

        // (4) OD cell (number; auto‐filled or custom)
        const tdOD = document.createElement("td");
        const inpOD = document.createElement("input");
        inpOD.type = "number";
        inpOD.placeholder = "0.00";
        inpOD.step = "0.01";
        inpOD.style.width = "60px";
        inpOD.readOnly = true; // locked until user picks a default config
        tdOD.appendChild(inpOD);
        tr.appendChild(tdOD);

        // (5) Weight cell (number; auto‐filled or custom)
        const tdWt = document.createElement("td");
        const inpWt = document.createElement("input");
        inpWt.type = "number";
        inpWt.placeholder = "0.00";
        inpWt.step = "0.01";
        inpWt.style.width = "60px";
        inpWt.readOnly = true;
        tdWt.appendChild(inpWt);
        tr.appendChild(tdWt);

        // (6) Multiconductor checkbox
        const tdMulti = document.createElement("td");
        const inpMulti = document.createElement("input");
        inpMulti.type = "checkbox";
        tdMulti.appendChild(inpMulti);
        tr.appendChild(tdMulti);

        // (7) Cable Group cell
        const tdGrp = document.createElement("td");
        const inpGrp = document.createElement("input");
        inpGrp.type = "number";
        inpGrp.step = "1";
        inpGrp.min = "1";
        inpGrp.style.width = "50px";
        inpGrp.value = "1";
        tdGrp.appendChild(inpGrp);
        tr.appendChild(tdGrp);

        // (8) Duplicate button cell
        const tdDup = document.createElement("td");
        const btnDup = document.createElement("button");
        btnDup.type = "button";
        btnDup.textContent = "⧉";
        btnDup.className = "duplicateBtn";
        btnDup.addEventListener("click", () => {
          const clone = createCableRow();
          clone.children[0].querySelector("input").value = inpTag.value;
          clone.children[1].querySelector("select").value = selCableType.value;
          const cfgClone = clone.children[2].querySelector("input");
          cfgClone.value = inpConfig.value;
          cfgClone.dispatchEvent(new Event("input"));
          const odClone = clone.children[3].querySelector("input");
          const wtClone = clone.children[4].querySelector("input");
          const multiClone = clone.children[5].querySelector("input");
          const grpClone = clone.children[6].querySelector("input");
          odClone.value = inpOD.value;
          wtClone.value = inpWt.value;
          multiClone.checked = inpMulti.checked;
          grpClone.value = inpGrp.value;
          odClone.readOnly = inpOD.readOnly;
          wtClone.readOnly = inpWt.readOnly;
          cableTbody.insertBefore(clone, tr.nextSibling);
        });
        tdDup.appendChild(btnDup);
        tr.appendChild(tdDup);

        // (9) Remove button cell
        const tdRm = document.createElement("td");
        const btnRm = document.createElement("button");
        btnRm.type = "button";
        btnRm.textContent = "✖";
        btnRm.className = "removeBtn";
        btnRm.addEventListener("click", () => {
          cableTbody.removeChild(tr);
        });
        tdRm.appendChild(btnRm);
        tr.appendChild(tdRm);

        // When “Cable Configuration” changes, auto‐fill OD/Weight if it matches a default
        inpConfig.addEventListener("input", () => {
          const val = inpConfig.value.trim();
          const matchIdx = cableOptions.findIndex(o => o.label === val);
          if (matchIdx >= 0) {
            // Matches a default → auto‐fill & lock
            inpOD.value    = cableOptions[matchIdx].OD.toFixed(2);
            inpWt.value    = cableOptions[matchIdx].weight.toFixed(2);
            inpOD.readOnly = true;
            inpWt.readOnly = true;
          } else {
            // Custom configuration → clear & unlock
            inpOD.value    = "";
            inpWt.value    = "";
            inpOD.readOnly = false;
            inpWt.readOnly = false;
          }
        });

        return tr;
      }

      // “Add Cable” button → append a blank row
      document.getElementById("addCableBtn").addEventListener("click", () => {
        cableTbody.appendChild(createCableRow());
      });
      // Start with one empty row
      document.getElementById("addCableBtn").click();

      // ─────────────────────────────────────────────────────────────
      // (C) NEC-2011 Sizing Helpers (Table 5 allowable area for small) :contentReference[oaicite:1]{index=1}
      // ─────────────────────────────────────────────────────────────
      const allowableAreaByWidth = {
        6:  7.0,
        9: 10.5,
        12:14.0,
        18:21.0,
        24:28.0,
        30:32.5,
        36:39.0
      };
      const standardWidths = [6, 9, 12, 18, 24, 30, 36];

      // NFPA 70 Table 392.22(A) “Column 2a” for Ladder (in²)
      const nfpaLadder = {
        6:  7.0,
        9: 10.5,
        12:14.0,
        18:21.0,
        24:28.0,
        30:32.5,
        36:39.0
      };
      // NFPA 70 Table 392.22(A) “Column 4a” for Solid Bottom (in²)
      const nfpaSolid = {
        6:  5.5,
        9:  8.0,
        12:11.0,
        18:16.5,
        24:22.0,
        30:27.5,
        36:33.0
      };

      function splitLargeSmall(cables) {
        const large = [], small = [];
        cables.forEach(c => {
          if (c.OD >= 1.55) large.push(c);
          else small.push(c);
        });
        return { large, small };
      }
      function sumDiameters(arr) {
        return arr.reduce((sum, c) => sum + c.OD, 0);
      }
      function sumAreas(arr) {
        return arr.reduce((sum, c) => sum + Math.PI * (c.OD/2)**2, 0);
      }
      function getAllowableArea(width, trayType) {
        const base = allowableAreaByWidth[width] || 0;
        return (trayType === "solid") ? base * 0.78 : base;
      }
      function computeNeededWidth(large, small, trayType) {
        let widthNeededLarge = 0;
        if (large.length > 0) {
          const sumD = sumDiameters(large);
          widthNeededLarge = (trayType === "solid") ? (sumD / 0.9) : sumD;
        }
        const areaNeededSmall = sumAreas(small);

        for (const W of standardWidths) {
          if (W < widthNeededLarge) continue;
          const allowA = getAllowableArea(W, trayType);
          if (small.length === 0 || areaNeededSmall <= allowA) {
            return W;
          }
        }
        return null;
      }

      // ─────────────────────────────────────────────────────────────
      // (D) Placement Helpers
      //   (1) placeLargeIgnoreBounds – bottom row for large (with optional spacing by larger OD)
      //   (2) placeSmallByPacking – true “tangent‐circle” packing
      // ─────────────────────────────────────────────────────────────

      // (1) Bottom‐row placement for large cables (y = r), ignoring tray width,
      //     but if spacingEnabled, add one‐diameter gap equal to the larger of the two radii.
      function placeLargeIgnoreBounds(largeCables, spacingEnabled) {
        // --- SORT largeCables BY DESCENDING OD (largest → smallest) ---
        const sortedLarge = largeCables.slice().sort((a, b) => b.OD - a.OD);

        const placed = [];
        sortedLarge.forEach((c, i) => {
          const r = c.OD / 2;
          let xCenter;
          if (i === 0) {
            // First large cable: center at r
            xCenter = r;
          } else {
            const prev = placed[i - 1];
            if (spacingEnabled) {
              // Use the larger radius of (prev.r, r):
              const largerRadius = Math.max(prev.r, r);
              const gap = 2 * largerRadius; // one full diameter of the larger cable
              xCenter = prev.x + prev.r + gap + r;
            } else {
              // No extra spacing: edge‐to‐edge
              xCenter = prev.x + prev.r + r;
            }
          }
          placed.push({
            x: xCenter,
            y: r,
            r: r,
            OD: c.OD,
            tag: c.tag,
            cableType: c.cableType,
            config: c.config,
            weight: c.weight
          });
        });
        return placed;
      }

      // (2) True “tangent‐circle” packing for small cables
      function placeSmallByPacking(smallCables, trayW, barrierX, basePlaced) {
        // Copy basePlaced into new array
        const placed = basePlaced.map(p => ({
          x: p.x, y: p.y, r: p.r, OD: p.OD,
          tag: p.tag, cableType: p.cableType, config: p.config, weight: p.weight
        }));
        // Sort small descending by OD
        const sorted = smallCables.slice().sort((a, b) => b.OD - a.OD);
        const EPS = 1e-6;

        sorted.forEach(c => {
          const r = c.OD / 2;
          let best = { x: null, y: Infinity };
          const candidates = [];

          // A1) Floor‐only at x = barrierX + r, y = r
          candidates.push({ x: barrierX + r, y: r });

          // A2) Tangent to floor + each placed p → x = p.x ± (p.r + r), y = r
          placed.forEach(p => {
            const leftX  = p.x - (p.r + r);
            const rightX = p.x + (p.r + r);
            if (leftX >= barrierX + r - EPS && leftX <= trayW - r + EPS) {
              candidates.push({ x: leftX, y: r });
            }
            if (rightX >= barrierX + r - EPS && rightX <= trayW - r + EPS) {
              candidates.push({ x: rightX, y: r });
            }
          });

          // A3) Tangent to two placed circles p & q (circle‐circle intersection)
          for (let i = 0; i < placed.length; i++) {
            const p = placed[i];
            const R1 = p.r + r;
            for (let j = i + 1; j < placed.length; j++) {
              const q = placed[j];
              const R2 = q.r + r;
              const dx = q.x - p.x, dy = q.y - p.y;
              const d2 = dx*dx + dy*dy, d = Math.sqrt(d2);
              if (
                d < EPS ||
                d > (R1 + R2) - EPS ||
                d < Math.abs(R1 - R2) + EPS
              ) {
                continue;
              }
              const a = (R1*R1 - R2*R2 + d2) / (2 * d);
              const h2 = R1*R1 - a*a;
              if (h2 < -EPS) continue;
              const h = Math.sqrt(Math.max(0, h2));
              const xm = p.x + (a * dx / d);
              const ym = p.y + (a * dy / d);
              const rx = -dy * (h / d), ry = dx * (h / d);

              const cand1 = { x: xm + rx, y: ym + ry };
              const cand2 = { x: xm - rx, y: ym - ry };
              [cand1, cand2].forEach(({ x, y }) => {
                if (
                  x >= barrierX + r - EPS &&
                  x <= trayW - r + EPS &&
                  y >= r - EPS
                ) {
                  candidates.push({ x: x, y: y });
                }
              });
            }
          }

          // A4) Tangent to barrier + each placed circle p
          placed.forEach(p => {
            const cx = barrierX + r;
            const dx = Math.abs(cx - p.x);
            const R = p.r + r;
            if (dx < R - EPS) {
              const offset = Math.sqrt(Math.max(0, R*R - dx*dx));
              const yCand1 = p.y + offset;
              if (yCand1 >= r - EPS) {
                candidates.push({ x: cx, y: yCand1 });
              }
            }
          });

          // B) FILTER valid candidates (in‐bounds, no overlap)
          candidates.forEach(pos => {
            const xCand = pos.x, yCand = pos.y;
            if (xCand - r < barrierX - EPS || xCand + r > trayW + EPS) return;
            if (yCand - r < -EPS) return;
            let overl = false;
            for (const p of placed) {
              const dx = xCand - p.x, dy = yCand - p.y;
              const req = p.r + r;
              if (dx*dx + dy*dy < (req - EPS)*(req - EPS)) {
                overl = true;
                break;
              }
            }
            if (!overl) {
              if (
                yCand < best.y - EPS ||
                (Math.abs(yCand - best.y) < EPS && xCand < best.x)
              ) {
                best = { x: xCand, y: yCand };
              }
            }
          });

          // C) FALL BACK if no valid tangent found
          if (best.x === null) {
            const xForced = barrierX + r;
            let yForced = r;
            placed.forEach(p => {
              const dx = Math.abs(xForced - p.x);
              if (dx < p.r + r - EPS) {
                const supTop = p.y + p.r + r;
                if (supTop > yForced) yForced = supTop;
              }
            });
            best = { x: xForced, y: yForced };
          }

          // D) Commit placement
          placed.push({
            x: best.x,
            y: best.y,
            r: r,
            OD: c.OD,
            tag: c.tag,
            cableType: c.cableType,
            config: c.config,
            weight: c.weight
          });
        });

        return placed;
      }

      // (3) Place an entire cable group within a given width and report width used
      function placeGroup(groupCables, maxWidth, spacingEnabled) {
        const { large: gLarge, small: gSmall } = splitLargeSmall(groupCables);
        let largePlaced = [];
        if (gLarge.length > 0) {
          largePlaced = placeLargeIgnoreBounds(gLarge, spacingEnabled);
        }
        let barrierX = 0;
        if (largePlaced.length > 0) {
          barrierX = Math.max(...largePlaced.map(p => p.x + p.r));
        }
        let finalPlaced = largePlaced;
        if (gSmall.length > 0) {
          finalPlaced = placeSmallByPacking(gSmall, maxWidth, barrierX, largePlaced);
        }
        const placed = largePlaced.concat(finalPlaced.slice(largePlaced.length));
        const widthUsed = placed.length > 0 ? Math.max(...placed.map(p => p.x + p.r)) : 0;
        return { placed, widthUsed, barrierX, largeCount: gLarge.length, smallCount: gSmall.length };
      }

      // (3) Place an entire cable group within a given width and report width used
      function placeGroup(groupCables, maxWidth, spacingEnabled) {
        const { large: gLarge, small: gSmall } = splitLargeSmall(groupCables);
        let largePlaced = [];
        if (gLarge.length > 0) {
          largePlaced = placeLargeIgnoreBounds(gLarge, spacingEnabled);
        }
        let barrierX = 0;
        if (largePlaced.length > 0) {
          barrierX = Math.max(...largePlaced.map(p => p.x + p.r));
        }
        let finalPlaced = largePlaced;
        if (gSmall.length > 0) {
          finalPlaced = placeSmallByPacking(gSmall, maxWidth, barrierX, largePlaced);
        }
        const placed = largePlaced.concat(finalPlaced.slice(largePlaced.length));
        const widthUsed = placed.length > 0 ? Math.max(...placed.map(p => p.x + p.r)) : 0;
        return { placed, widthUsed, barrierX, largeCount: gLarge.length, smallCount: gSmall.length };
      }


      // ─────────────────────────────────────────────────────────────
      // (E) “Draw Tray” button: gather inputs → metrics → placement → draw SVG → show warnings
      // ─────────────────────────────────────────────────────────────
      document.getElementById("drawBtn").addEventListener("click", () => {
        // 1) Tray parameters
        const trayW    = parseFloat(document.getElementById("trayWidth").value);
        const trayD    = parseFloat(document.getElementById("trayDepth").value);
        const trayType = document.getElementById("trayType").value;
        const trayName = document.getElementById("trayName").value.trim();

        // 2) Gather cables from the table
        const rows = Array.from(cableTbody.querySelectorAll("tr"));
        const cables = [];
        for (const row of rows) {
          const tagVal     = row.children[0].querySelector("input").value.trim();
          const cableType  = row.children[1].querySelector("select").value;
          const configVal  = row.children[2].querySelector("input").value.trim();
          const odVal      = parseFloat(row.children[3].querySelector("input").value);
          const wtVal      = parseFloat(row.children[4].querySelector("input").value);
          const multiVal   = row.children[5].querySelector("input").checked;
          const groupVal   = parseInt(row.children[6].querySelector("input").value) || 1;

          if (!tagVal) {
            alert("ERROR: Every cable row requires a Tag.");
            return;
          }
          if (!cableType) {
            alert(`ERROR: Every cable row requires a Cable Type.`);
            return;
          }
          if (!configVal) {
            alert(`ERROR: Every cable row requires a Cable Configuration.`);
            return;
          }
          if (isNaN(odVal) || isNaN(wtVal)) {
            alert(`ERROR: Every cable row requires numeric OD and Weight.`);
            return;
          }

          cables.push({
            tag: tagVal,
            cableType: cableType,
            config: configVal,
            OD: odVal,
            weight: wtVal,
            multi: multiVal,
            group: groupVal
          });
        }
        if (cables.length === 0) {
          alert("ERROR: Add at least one cable before drawing the tray.");
          return;
        }

        // 3) Compute extra metrics: small‐area & large‐diameter sums
        let sumSmallArea = 0;
        let sumLargeDiam = 0;
        cables.forEach(c => {
          if (c.OD < 1.55) {
            sumSmallArea += Math.PI * (c.OD/2)**2;
          } else {
            sumLargeDiam += c.OD;
          }
        });

        // 4) Split large vs. small, compute recommended width
        const { large, small } = splitLargeSmall(cables);
        let recommendedWidth = computeNeededWidth(large, small, trayType);

        // 5) Check if user wants one‐diameter spacing between 4/0+ cables
        const spacingEnabled = document.getElementById("largeSpacing").checked;

        // 6) Place cables group by group
        const groupIds = [...new Set(cables.map(c => c.group))].sort((a,b) => a - b);
        let placedAll = [];
        let barrierLines = [];
        let offset = 0;
        let groupHTML = "";

        // First pass: determine natural width of each group
        const groupInfo = [];
        let totalWidthNeeded = 0;
        groupIds.forEach(gid => {
          const gCables = cables.filter(c => c.group === gid);
          const measure = placeGroup(gCables, trayW, spacingEnabled);
          groupInfo.push({ gid, cables: gCables, width: measure.widthUsed });
          totalWidthNeeded += measure.widthUsed;
        });

        // Adjust recommended width based on actual layout requirement
        const layoutWidth = standardWidths.find(w => w >= totalWidthNeeded) || null;
        if (!recommendedWidth || (layoutWidth && layoutWidth > recommendedWidth)) {
          recommendedWidth = layoutWidth;
        }

        const scaleFactor = totalWidthNeeded > trayW ? trayW / totalWidthNeeded : 1;

        // Second pass: actual placement using scaled widths
        groupInfo.forEach(info => {
          const widthLimit = info.width * scaleFactor;
          const result = placeGroup(info.cables, widthLimit, spacingEnabled);
          const widthUsed = result.widthUsed;
          const areaAll = sumAreas(info.cables);
          const fillP = widthUsed > 0 ? Math.min(100, (areaAll / (widthUsed * trayD)) * 100) : 0;
          groupHTML += `<p><strong>Group ${info.gid} Fill %:</strong> ${fillP.toFixed(0)} %</p>`;
          if (offset > 0) barrierLines.push(offset);
          if (result.largeCount > 0 && result.smallCount > 0) barrierLines.push(offset + result.barrierX);
          result.placed.forEach(p => { p.x += offset; placedAll.push(p); });
          offset += widthUsed;
        });

        // If combined width exceeds tray width, scale positions to fit
        const totalWidthUsed = offset;
        if (totalWidthUsed > trayW + 1e-6) {
          const fitScale = trayW / totalWidthUsed;
          placedAll.forEach(p => { p.x *= fitScale; });
          barrierLines = barrierLines.map(x => x * fitScale);
          offset = trayW;
        }

        // 7) Determine if ALL cables are Control/Signal
        const allCS = cables.every(c => c.cableType === "Control" || c.cableType === "Signal");

        // 8) NFPA 70 Table 392.22(A) warning (area vs sumLargeDiam) — only if NOT allCS
        let nfpaWarning = "";
        if (!allCS) {
          const baseAllow = (trayType === "ladder") ? (nfpaLadder[trayW] || 0) : (nfpaSolid[trayW] || 0);
          const penaltyFactor = (trayType === "ladder") ? 1.2 : 1.0;
          if (baseAllow > 0) {
            let nfpaAllowable = baseAllow - (penaltyFactor * sumLargeDiam);
            if (nfpaAllowable < 0) nfpaAllowable = 0;
            if (sumSmallArea > nfpaAllowable + 1e-6) {
              nfpaWarning = `
                <p class="nfpaWarn">
                  NFPA 70 Table 392.22(A) WARNING:<br>
                  Small‐cable area (${sumSmallArea.toFixed(2)} in²) exceeds NFPA allowable
                  (${nfpaAllowable.toFixed(2)} in²) for a ${trayW}" ${trayType === "ladder" ? "Ladder" : "Solid Bottom"} tray.
                </p>`;
            }
          }
        }

        // 9) NFPA 70 392.22(A)(2) & (4) warning for Control/Signal‐only
        let csWarning = "";
        const overallFill = (sumSmallArea / (trayW * trayD)) * 100;
        if (allCS) {
          if (trayType === "ladder" && overallFill > 50) {
            csWarning = `
              <p class="nfpaWarn">
                NFPA 70 392.22(A)(2) WARNING:<br>
                All cables are Control/Signal and Fill % (${overallFill.toFixed(0)} %) exceeds 50 % for Ladder tray.
              </p>`;
          } else if (trayType === "solid" && overallFill > 40) {
            csWarning = `
              <p class="nfpaWarn">
                NFPA 70 392.22(A)(4) WARNING:<br>
                All cables are Control/Signal and Fill % (${overallFill.toFixed(0)} %) exceeds 40 % for Solid Bottom tray.
              </p>`;
          }
        }

        // 10) Summarize metrics + total weight
        const totalWeight = cables.reduce((sum, c) => sum + c.weight, 0);
        let resultsHTML = `
          <p>
            <strong>Using Tray Width:</strong> ${trayW}"<br>
            <strong>Tray Depth:</strong> ${trayD}"<br>
            <strong>Type:</strong> ${trayType === "ladder" ? "Ladder (50 % fill)" : "Solid Bottom (40 % fill)"}
          </p>

          <p>
            <strong>Cables Smaller than 4/0 Cross‐Sectional Area:</strong>
            ${sumSmallArea.toFixed(2)} in²
          </p>
          ${groupHTML}
          <p>
            <strong>Sum of 4/0 and Larger Cable Diameters:</strong>
            ${sumLargeDiam.toFixed(2)} in
          </p>

          <p>
            <strong>Total Cable Weight:</strong> ${totalWeight.toFixed(2)} lbs/ft
          </p>
          ${nfpaWarning}
          ${csWarning}
        `;

        // Store for “Expand Image”
        lastPlaced   = placedAll;
        lastBarriers = barrierLines;
        lastTrayW    = trayW;
        lastTrayD    = trayD;
        lastType     = trayType;
        lastScale    = 20;  // px/in for small view

        // 14) Detect overflow horizontally/vertically
        let overflowHoriz = false;
        let overflowVert  = false;
        placedAll.forEach(p => {
          if (p.x + p.r > trayW + 1e-6) overflowHoriz = true;
          if (p.y + p.r > trayD + 1e-6) overflowVert  = true;
        });

        // 15) Draw the SVG (20 px/in) but with extra rows for “name” and “dimension”
        const scale = lastScale;
        const nameRowPx    = 20;   // 20px for the tray name
        const dimRowPx     = 24;   // more room for dimension text
        const trayRowPx    = trayD * scale;
        const totalSvgH    = nameRowPx + dimRowPx + trayRowPx;
        const totalSvgW    = trayW * scale;
        const nameTextY    = 14;   // Y‐coordinate to place the tray name text
        const dimLineY     = nameRowPx + 8;         // mid‐height of dimension row
        const trayTopY     = nameRowPx + dimRowPx;  // Y‐coordinate of tray top edge

        let svg = `
          <svg
            width="${totalSvgW}"
            height="${totalSvgH}"
            style="background:#f9f9f9; border:1px solid #999;"
          >
        `;

        // (A) Draw the tray name (if provided)
        if (trayName) {
          svg += `
            <text
              x="${(totalSvgW/2).toFixed(2)}"
              y="${nameTextY}"
              font-size="16px"
              text-anchor="middle"
              fill="#000"
              font-family="Arial, sans-serif"
            >${trayName}</text>
          `;
        }

        // (B) Draw separation barriers
        barrierLines.forEach(x => {
          const xp = (x * scale).toFixed(2);
          svg += `
            <line
              x1="${xp}" y1="${trayTopY}"
              x2="${xp}" y2="${(trayTopY + trayRowPx).toFixed(2)}"
              stroke="#aa3300"
              stroke-width="2"
              stroke-dasharray="4 2"
            />
          `;
        });

        // (B2) Dimension lines for each zone
        const zoneBounds = [0, ...barrierLines, trayW];
        for (let i = 0; i < zoneBounds.length - 1; i++) {
          const xs = zoneBounds[i] * scale;
          const xe = zoneBounds[i+1] * scale;
          const mid = (xs + xe) / 2;
          const wText = (zoneBounds[i+1] - zoneBounds[i]).toFixed(1) + '"';
          svg += `
            <line x1="${xs.toFixed(2)}" y1="${dimLineY}" x2="${xe.toFixed(2)}" y2="${dimLineY}" stroke="#000" stroke-width="1" />
            <line x1="${xs.toFixed(2)}" y1="${dimLineY-4}" x2="${xs.toFixed(2)}" y2="${dimLineY+4}" stroke="#000" stroke-width="1" />
            <line x1="${xe.toFixed(2)}" y1="${dimLineY-4}" x2="${xe.toFixed(2)}" y2="${dimLineY+4}" stroke="#000" stroke-width="1" />
            <text x="${mid.toFixed(2)}" y="${dimLineY+10}" font-size="10px" text-anchor="middle" font-family="Arial, sans-serif">${wText}</text>
          `;
        }

        // (C) Draw the tray rectangle (starts at trayTopY)
        svg += `
          <rect
            x="0" y="${trayTopY}"
            width="${(trayW * scale).toFixed(2)}"
            height="${(trayD * scale).toFixed(2)}"
            fill="none"
            stroke="#333"
            stroke-width="2"
          />
        `;

        // (E) Draw each circle (all shifted down by trayTopY, and Y‐flipped inside the tray)
        placedAll.forEach(p => {
          const cx = p.x * scale;
          const cy = trayTopY + ((trayD - p.y) * scale);
          const r  = p.r * scale;
          svg += `
            <circle
              cx="${cx.toFixed(2)}"
              cy="${cy.toFixed(2)}"
              r="${r.toFixed(2)}"
              fill="#66ccff"
              stroke="#0066aa"
              stroke-width="1"
            >
              <title>
Cable Tag: ${p.tag}
Cable Type: ${p.cableType}
Configuration: ${p.config}
OD: ${p.OD.toFixed(2)}″
Wt: ${p.weight.toFixed(2)} lbs/ft
              </title>
            </circle>
          `;
        });

        svg += `</svg>`;
        document.getElementById("svgContainer").innerHTML = svg;

        // 16) Show overflow warnings & recommendations
        if (overflowHoriz || overflowVert) {
          if (overflowHoriz) {
            if (recommendedWidth && recommendedWidth > trayW) {
              resultsHTML += `
                <p class="warning">
                  WARNING: Some cables extend beyond the tray width (${trayW}").
                </p>
                <p class="recommend">
                  Recommend larger standard width: ${recommendedWidth}" 
                </p>`;
            } else {
              resultsHTML += `
                <p class="warning">
                  WARNING: Some cables extend beyond the tray width (${trayW}").
                </p>
                <p class="recommend">
                  No larger standard width can accommodate all cables.
                </p>`;
            }
          }
          if (overflowVert) {
            const neededDepth = Math.max(...placedAll.map(p => p.y + p.r));
            resultsHTML += `
              <p class="warning">
                WARNING: Some cables extend above the tray depth (${trayD}").
              </p>
              <p class="recommend">
                Recommend increasing tray depth to at least ${neededDepth.toFixed(2)}".
              </p>`;
          }
        }
        document.getElementById("results").innerHTML = resultsHTML;
      });

      // ─────────────────────────────────────────────────────────────
      // (F) “Expand Image” button: popup at 160 px/in (double the 80 px/in)
      //           (We apply the same “name + dimension + tray” logic, but with a larger scale.)
      // ─────────────────────────────────────────────────────────────
      document.getElementById("expandBtn").addEventListener("click", () => {
        if (!lastPlaced) {
          alert("Please click “Draw Tray” first, then Expand.");
          return;
        }
        const bigScale = 160;  // 160 px/in for high resolution
        const trayW = lastTrayW, trayD = lastTrayD;
        const trayName = document.getElementById("trayName").value.trim();
        const nameRowPx    = 30;   // give more room for big text
        const dimRowPx     = 36;   // more room for dimension text
        const trayRowPx    = trayD * bigScale;
        const totalSvgH    = nameRowPx + dimRowPx + trayRowPx;
        const totalSvgW    = trayW * bigScale;
        const nameTextY    = 24;
        const dimLineY     = nameRowPx + 12;    
        const trayTopY     = nameRowPx + dimRowPx;

        let svg = `
          <svg
            width="${totalSvgW}"
            height="${totalSvgH}"
            style="background:#f9f9f9; border:1px solid #333;"
          >
        `;

        // (A) Tray Name
        if (trayName) {
          svg += `
            <text
              x="${(totalSvgW/2).toFixed(2)}"
              y="${nameTextY}"
              font-size="24px"
              text-anchor="middle"
              fill="#000"
              font-family="Arial, sans-serif"
            >${trayName}</text>
          `;
        }

        // (B) Draw separation barriers
        lastBarriers.forEach(x => {
          const xp = (x * bigScale).toFixed(2);
          svg += `
            <line
              x1="${xp}" y1="${trayTopY}"
              x2="${xp}" y2="${(trayTopY + trayRowPx).toFixed(2)}"
              stroke="#aa3300"
              stroke-width="4"
              stroke-dasharray="12 6"
            />
          `;
        });

        // (B2) Dimension lines for each zone
        const bigZone = [0, ...lastBarriers, trayW];
        for (let i = 0; i < bigZone.length - 1; i++) {
          const xs = bigZone[i] * bigScale;
          const xe = bigZone[i+1] * bigScale;
          const mid = (xs + xe) / 2;
          const wText = (bigZone[i+1] - bigZone[i]).toFixed(1) + '"';
          svg += `
            <line x1="${xs.toFixed(2)}" y1="${dimLineY}" x2="${xe.toFixed(2)}" y2="${dimLineY}" stroke="#000" stroke-width="2" />
            <line x1="${xs.toFixed(2)}" y1="${dimLineY-8}" x2="${xs.toFixed(2)}" y2="${dimLineY+8}" stroke="#000" stroke-width="2" />
            <line x1="${xe.toFixed(2)}" y1="${dimLineY-8}" x2="${xe.toFixed(2)}" y2="${dimLineY+8}" stroke="#000" stroke-width="2" />
            <text x="${mid.toFixed(2)}" y="${dimLineY+16}" font-size="18px" text-anchor="middle" font-family="Arial, sans-serif">${wText}</text>
          `;
        }

        // (C) Draw the tray rectangle
        svg += `
          <rect
            x="0" y="${trayTopY}"
            width="${(trayW * bigScale).toFixed(2)}"
            height="${(trayD * bigScale).toFixed(2)}"
            fill="none"
            stroke="#333"
            stroke-width="4"
          />
        `;

        // (D) Draw each circle + inline text inside
        lastPlaced.forEach(p => {
          const cx = p.x * bigScale;
          const cy = trayTopY + ((trayD - p.y) * bigScale);
          const r  = p.r * bigScale;
          svg += `
            <circle
              cx="${cx.toFixed(2)}"
              cy="${cy.toFixed(2)}"
              r="${r.toFixed(2)}"
              fill="#66ccff"
              stroke="#0066aa"
              stroke-width="2"
            />
          `;

          // Insert multiline <text> inside each circle
          const fontSize = Math.min(r * 0.15, 20);
          const lines = [
            `${p.tag}`,
            `${p.cableType}`,
            `${p.config}`,
            `OD: ${p.OD.toFixed(2)}″`,
            `Wt: ${p.weight.toFixed(2)}`
          ];
          const lineHeight = fontSize * 1.1;
          const textBlockHeight = lines.length * lineHeight;
          let yStart = cy - textBlockHeight / 2 + lineHeight / 2;

          lines.forEach((ln, idx) => {
            svg += `
              <text
                x="${cx.toFixed(2)}"
                y="${(yStart + idx * lineHeight).toFixed(2)}"
                font-size="${fontSize}px"
                text-anchor="middle"
                fill="#000"
                stroke="none"
                font-family="Arial, sans-serif"
                pointer-events="none"
              >
                ${ln}
              </text>
            `;
          });
        });

        svg += `</svg>`;

        document.getElementById("expandedSVG").innerHTML = svg;
        document.getElementById("overlay").style.display = "flex";
      });

      // ─────────────────────────────────────────────────────────────
      // (G) Copy SVG to clipboard
      // ─────────────────────────────────────────────────────────────
      document.getElementById("copyBtn").addEventListener("click", () => {
        const container = document.getElementById("expandedSVG");
        const svgElem = container.querySelector("svg");
        if (!svgElem) {
          alert("No expanded SVG found to copy.");
          return;
        }
        const svgText = svgElem.outerHTML;
        navigator.clipboard.writeText(svgText).then(() => {
          alert("SVG markup copied to clipboard!");
        }).catch(err => {
          alert("Error copying SVG: " + err);
        });
      });

      // ─────────────────────────────────────────────────────────────
      // (H) Print SVG in new window
      // ─────────────────────────────────────────────────────────────
      document.getElementById("printBtn").addEventListener("click", () => {
        const container = document.getElementById("expandedSVG");
        const svgElem = container.querySelector("svg");
        if (!svgElem) {
          alert("No expanded SVG found to print.");
          return;
        }
        const svgText = svgElem.outerHTML;
        const printWindow = window.open("", "_blank");
        printWindow.document.write(`<!DOCTYPE html>
<html>
<head>
  <title>Print Cable Tray</title>
</head>
<body style="margin:0; padding:0;">
  ${svgText}
</body>
</html>`);
        printWindow.document.close();
        printWindow.focus();
        setTimeout(() => {
          printWindow.print();
        }, 200);
      });

      // ─────────────────────────────────────────────────────────────
      // (I) Copy PNG to clipboard: SVG → canvas → PNG Blob → clipboard
      // ─────────────────────────────────────────────────────────────
      document.getElementById("copyPngBtn").addEventListener("click", () => {
        const container = document.getElementById("expandedSVG");
        const svgElem = container.querySelector("svg");
        if (!svgElem) {
          alert("No expanded SVG found to copy as PNG.");
          return;
        }
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgElem);
        const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);

        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width  = svgElem.getAttribute("width");
          canvas.height = svgElem.getAttribute("height");
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          canvas.toBlob(pngBlob => {
            if (!pngBlob) {
              alert("Failed to create PNG blob.");
              URL.revokeObjectURL(url);
              return;
            }
            const clipboardItem = new ClipboardItem({ "image/png": pngBlob });
            navigator.clipboard.write([clipboardItem]).then(() => {
              alert("PNG copied to clipboard!");
              URL.revokeObjectURL(url);
            }).catch(err => {
              alert("Error copying PNG: " + err);
              URL.revokeObjectURL(url);
            });
          }, "image/png");
        };
        img.onerror = () => {
          alert("Failed to load SVG into image for PNG conversion.");
          URL.revokeObjectURL(url);
        };
        img.src = url;
      });

      // ─────────────────────────────────────────────────────────────
      // (J) “Close” button hides the overlay
      // ─────────────────────────────────────────────────────────────
      document.getElementById("popupClose").addEventListener("click", () => {
        document.getElementById("overlay").style.display = "none";
      });

      // ─────────────────────────────────────────────────────────────
      // (K) Excel Export: gather table → create workbook → download
      // ─────────────────────────────────────────────────────────────
      document.getElementById("exportExcelBtn").addEventListener("click", () => {
        const rows = Array.from(cableTbody.querySelectorAll("tr"));
        if (rows.length === 0) {
          alert("No cables to export.");
          return;
        }
        // Build 2D array: header + each row’s [Tag, Cable Type, Cable Configuration, OD, Weight, Group]
        const data = [["Tag", "Cable Type", "Cable Configuration", "OD", "Weight", "Multiconductor Cable", "Group"]];
        rows.forEach(row => {
          const tag       = row.children[0].querySelector("input").value.trim();
          const cableType = row.children[1].querySelector("select").value;
          const config    = row.children[2].querySelector("input").value.trim();
          const od        = row.children[3].querySelector("input").value.trim();
          const weight    = row.children[4].querySelector("input").value.trim();
          const multi     = row.children[5].querySelector("input").checked ? "TRUE" : "FALSE";
          const group     = row.children[6].querySelector("input").value.trim();
          data.push([tag, cableType, config, od, weight, multi, group]);
        });
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(wb, ws, "Cables");
        XLSX.writeFile(wb, "CableList.xlsx");
      });

      // ─────────────────────────────────────────────────────────────
      // (L) Excel Import: file‐picker → parse → populate table
      // ─────────────────────────────────────────────────────────────
      document.getElementById("importExcelBtn").addEventListener("click", () => {
        document.getElementById("importExcelInput").click();
      });
      document.getElementById("importExcelInput").addEventListener("change", (evt) => {
        const file = evt.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const data = e.target.result;
          const wb = XLSX.read(data, { type: "binary" });
          const firstSheet = wb.Sheets[wb.SheetNames[0]];
          const jsonArr = XLSX.utils.sheet_to_json(firstSheet, { defval: "" });
          if (jsonArr.length === 0) {
            alert("Excel sheet is empty.");
            return;
          }
          // Expect columns: Tag, Cable Type, Cable Configuration, OD, Weight, Multiconductor Cable, Group
          cableTbody.innerHTML = "";
          jsonArr.forEach((obj, idx) => {
            const { Tag, "Cable Type": CableType, "Cable Configuration": Config, OD, Weight, "Multiconductor Cable": Multi, Group } = obj;
            if (
              typeof Tag === "undefined" ||
              typeof CableType === "undefined" ||
              typeof Config === "undefined" ||
              typeof OD === "undefined" ||
              typeof Weight === "undefined"
            ) {
              alert(`Row ${idx + 2} missing one of: Tag, Cable Type, Cable Configuration, OD, Weight.`);
              return;
            }
            const newRow = createCableRow();
            newRow.children[0].querySelector("input").value = Tag;
            // Set the "Cable Type" dropdown
            newRow.children[1].querySelector("select").value = CableType;
            // Set the "Cable Configuration" input
            newRow.children[2].querySelector("input").value = Config;
            // Trigger input event so OD/Weight auto‐fill if default, else remain custom
            const cfgInput = newRow.children[2].querySelector("input");
            cfgInput.dispatchEvent(new Event("input"));
            // If not matched a default, fill custom OD/Weight
            const odInput = newRow.children[3].querySelector("input");
            const wtInput = newRow.children[4].querySelector("input");
            const multiInput = newRow.children[5].querySelector("input");
            const grpInput = newRow.children[6].querySelector("input");
            if (cableOptions.findIndex(o => o.label === Config) < 0) {
              odInput.value = parseFloat(OD).toFixed(2);
              wtInput.value = parseFloat(Weight).toFixed(2);
              odInput.readOnly = false;
              wtInput.readOnly = false;
            }
            multiInput.checked = String(Multi).toLowerCase() === "true";
            grpInput.value = Group || 1;
            cableTbody.appendChild(newRow);
          });
          alert("Excel imported. Correct any unrecognized configurations if needed.");
          document.getElementById("importExcelInput").value = "";
        };
        reader.readAsBinaryString(file);
      });

      // (L2) Import Help button
      document.getElementById("importHelpBtn").addEventListener("click", () => {
        alert(
          "Import Instructions:\n" +
          "1. Click 'Export Excel' to download a template.\n" +
          "2. Fill in Tag, Cable Type, Cable Configuration, OD, Weight, Multiconductor Cable, and Group.\n" +
          "3. Save the file then choose it with 'Import Excel'."
        );
      });

      // (L2) Import Help button
      document.getElementById("importHelpBtn").addEventListener("click", () => {
        alert(
          "Import Instructions:\n" +
          "1. Click 'Export Excel' to download a template.\n" +
          "2. Fill in Tag, Cable Type, Cable Configuration, OD, Weight, Multiconductor Cable, and Group.\n" +
          "3. Save the file then choose it with 'Import Excel'."
        );
      });

      // (L2) Import Help button
      document.getElementById("importHelpBtn").addEventListener("click", () => {
        alert(
          "Import Instructions:\n" +
          "1. Click 'Export Excel' to download a template.\n" +
          "2. Fill in Tag, Cable Type, Cable Configuration, OD, Weight, Multiconductor Cable, and Group.\n" +
          "3. Save the file then choose it with 'Import Excel'."
        );
      });

      // (L2) Import Help button
      document.getElementById("importHelpBtn").addEventListener("click", () => {
        alert(
          "Import Instructions:\n" +
          "1. Click 'Export Excel' to download a template.\n" +

          "2. Fill in Tag, Cable Type, Cable Configuration, OD, Weight, Multiconductor Cable, and Group.\n" +

          "3. Save the file then choose it with 'Import Excel'."
        );
      });

      // ─────────────────────────────────────────────────────────────
      // (M) Profile Management (localStorage)
      // ─────────────────────────────────────────────────────────────
      const profileList = document.getElementById("profileList");
      function refreshProfileList() {
        profileList.innerHTML = "";
        const keys = Object.keys(localStorage).filter(k => k.startsWith("trayProfile_"));
        if (keys.length === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "-- no profiles saved --";
          profileList.appendChild(opt);
          return;
        }
        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "-- select profile --";
        profileList.appendChild(defaultOpt);
        keys.sort();
        keys.forEach(key => {
          const profileName = key.replace("trayProfile_", "");
          const opt = document.createElement("option");
          opt.value = profileName;
          opt.textContent = profileName;
          profileList.appendChild(opt);
        });
      }

      // Save profile
      document.getElementById("saveProfileBtn").addEventListener("click", () => {
        const name = prompt("Enter a name for this cable profile:");
        if (!name) return;
        const rows = Array.from(cableTbody.querySelectorAll("tr"));
        const arr = [];
        for (const row of rows) {
          const tagVal     = row.children[0].querySelector("input").value.trim();
          const cableType  = row.children[1].querySelector("select").value;
          const configVal  = row.children[2].querySelector("input").value.trim();
          const odVal      = parseFloat(row.children[3].querySelector("input").value);
          const wtVal      = parseFloat(row.children[4].querySelector("input").value);
          const multiVal   = row.children[5].querySelector("input").checked;
          const groupVal   = parseInt(row.children[6].querySelector("input").value) || 1;
          if (!tagVal || !cableType || !configVal || isNaN(odVal) || isNaN(wtVal)) {
            alert("All rows must have Tag, Cable Type, Configuration, OD, and Weight before saving.");
            return;
          }
          arr.push({
            tag: tagVal,
            cableType: cableType,
            config: configVal,
            OD: odVal,
            weight: wtVal,
            multi: multiVal,
            group: groupVal
          });
        }
        try {
          localStorage.setItem("trayProfile_" + name, JSON.stringify(arr));
          alert(`Profile "${name}" saved.`);
          refreshProfileList();
        } catch (e) {
          alert("Error saving profile: " + e.message);
        }
      });

      // Load profile
      document.getElementById("loadProfileBtn").addEventListener("click", () => {
        const profileName = profileList.value;
        if (!profileName) {
          alert("Select a profile to load.");
          return;
        }
        const json = localStorage.getItem("trayProfile_" + profileName);
        if (!json) {
          alert(`Profile "${profileName}" not found.`);
          refreshProfileList();
          return;
        }
        let arr;
        try {
          arr = JSON.parse(json);
        } catch (e) {
          alert("Error parsing profile data: " + e.message);
          return;
        }
        cableTbody.innerHTML = "";
        arr.forEach(cable => {
          const newRow = createCableRow();
          newRow.children[0].querySelector("input").value = cable.tag;
          newRow.children[1].querySelector("select").value = cable.cableType;
          newRow.children[2].querySelector("input").value = cable.config;
          // Trigger input event so OD/Weight auto‐fill if default
          const cfgInput = newRow.children[2].querySelector("input");
          cfgInput.dispatchEvent(new Event("input"));
          const odInput = newRow.children[3].querySelector("input");
          const wtInput = newRow.children[4].querySelector("input");
          const multiInput = newRow.children[5].querySelector("input");
          const grpInput = newRow.children[6].querySelector("input");
          if (cableOptions.findIndex(o => o.label === cable.config) < 0) {
            odInput.value = cable.OD.toFixed(2);
            wtInput.value = cable.weight.toFixed(2);
            odInput.readOnly = false;
            wtInput.readOnly = false;
          }
          multiInput.checked = !!cable.multi;
          grpInput.value = cable.group || 1;
          cableTbody.appendChild(newRow);
        });
        alert(`Profile "${profileName}" loaded.`);
      });

      // Delete profile
      document.getElementById("deleteProfileBtn").addEventListener("click", () => {
        const profileName = profileList.value;
        if (!profileName) {
          alert("Select a profile to delete.");
          return;
        }
        if (!confirm(`Delete profile "${profileName}"?`)) return;
        localStorage.removeItem("trayProfile_" + profileName);
        alert(`Profile "${profileName}" deleted.`);
        refreshProfileList();
      });

      // Initialize profile dropdown
      refreshProfileList();
    });
  </script>
</body>
</html>
